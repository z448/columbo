#!/usr/bin/env perl

use 5.010;
use warnings;
use strict;

use Errno;
use Net::OpenSSH;
use Data::Dumper;
use JSON::PP;
use Getopt::Std;


my $opt = {};
getopts('f:', $opt);

# read host config; must be json containing ipaddress/hostname, username, password, path to directory to be monitored 
my $c;
if(-f $opt->{f}){
  open(my $fh,'<', $opt->{f}) || die "cant open $opt->{f}: $!"
  local $/;
  $c = decode_son scalar <$fh>;
  close $fh;
}


my @hosts = (); die "ADD HOSTS";

my $file = '/tmp/notifs';
my $cmd = 'perl /tmp/notifs';

{
    local $/;
    my $notifs = <DATA>;
    open(my $fh,'>',$file) || die "cant open $file: $!";
    print $fh $notifs;
}

my (%pid, %ssh);
for my $host (@hosts) {
  $ssh{$host} = Net::OpenSSH->new($host, async => 1);
}
for my $host (@hosts) {
  $pid{$host} = $ssh{$host}->scp_put({async => 1}, $file, $file)
    or warn "scp_put to $host failed: " . $ssh{$host}->error . "\n";
}

for my $host (@hosts) {
  if (my $pid = $pid{$host}) {
    if (waitpid($pid, 0) > 0) {
      my $exit = ($? >> 8);
      $exit and warn "transfer of file to $host failed ($exit)\n";
    }
    else {
      no strict;
      redo if ($! == EINTR);
      warn "waitpid($pid) failed: $!\n";
    }
  }
}

my %conn = map { $_ => Net::OpenSSH->new($_, async => 1) } @hosts;
my @pid;
for my $host (@hosts) {
        open my($fh), '>', "/tmp/out-$host.txt"
              or die "unable to create file: $!";
              push @pid, $conn{$host}->spawn({stdout_fh => $fh}, $cmd);
          }

          waitpid($_, 0) for @pid;


__DATA__
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Filesys/Notify/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILESYS_NOTIFY_SIMPLE';
  package Filesys::Notify::Simple;use strict;use 5.008_001;our$VERSION='0.12';use Carp ();use Cwd;use constant NO_OPT=>$ENV{PERL_FNS_NO_OPT};sub new {my($class,$path)=@_;unless (ref$path eq 'ARRAY'){Carp::croak('Usage: Filesys::Notify::Simple->new([ $path1, $path2 ])')}my$self=bless {paths=>$path },$class;$self->init;$self}sub wait {my($self,$cb)=@_;$self->{watcher}||= $self->{watcher_cb}->(@{$self->{paths}});$self->{watcher}->($cb)}sub init {my$self=shift;local $@;if ($^O eq 'linux' &&!NO_OPT && eval {require Linux::Inotify2;1}){$self->{watcher_cb}=\&wait_inotify2}elsif ($^O eq 'darwin' &&!NO_OPT && eval {require Mac::FSEvents;1}){$self->{watcher_cb}=\&wait_fsevents}elsif ($^O eq 'freebsd' &&!NO_OPT && eval {require Filesys::Notify::KQueue;1}){$self->{watcher_cb}=\&wait_kqueue}elsif ($^O eq 'MSWin32' &&!NO_OPT && eval {require Win32::ChangeNotify;1}){$self->{watcher_cb}=mk_wait_win32(0)}elsif ($^O eq 'cygwin' &&!NO_OPT && eval {require Win32::ChangeNotify;1}){$self->{watcher_cb}=mk_wait_win32(1)}else {$self->{watcher_cb}=\&wait_timer}}sub wait_inotify2 {my@path=@_;Linux::Inotify2->import;my$inotify=Linux::Inotify2->new;my$fs=_full_scan(@path);for my$path (keys %$fs){$inotify->watch($path,&IN_MODIFY|&IN_CREATE|&IN_DELETE|&IN_DELETE_SELF|&IN_MOVE_SELF|&IN_MOVE)}return sub {my$cb=shift;$inotify->blocking(1);my@events=$inotify->read;$cb->(map {+{path=>$_->fullname }}@events)}}sub wait_fsevents {require IO::Select;my@path=@_;my$fs=_full_scan(@path);my$sel=IO::Select->new;my%events;for my$path (@path){my$fsevents=Mac::FSEvents->new({path=>$path,latency=>1 });my$fh=$fsevents->watch;$sel->add($fh);$events{fileno$fh}=$fsevents}return sub {my$cb=shift;my@ready=$sel->can_read;my@events;for my$fh (@ready){my$fsevents=$events{fileno$fh};my%uniq;my@path=grep!$uniq{$_}++,map {$_->path}$fsevents->read_events;my$new_fs=_full_scan(@path);my$old_fs=+{map {($_=>$fs->{$_})}keys %$new_fs };_compare_fs($old_fs,$new_fs,sub {push@events,{path=>$_[0]}});$fs->{$_}=$new_fs->{$_}for keys %$new_fs;last if@events}$cb->(@events)}}sub wait_kqueue {my@path=@_;my$kqueue=Filesys::Notify::KQueue->new(path=>\@path);return sub {$kqueue->wait(shift)}}sub mk_wait_win32 {my ($is_cygwin)=@_;return sub {my@path=@_;my$fs=_full_scan(@path);my (@notify,@fskey);for my$path (keys %$fs){my$winpath=$is_cygwin ? Cygwin::posix_to_win_path($path): $path;push@notify,Win32::ChangeNotify->new($winpath,0,0x1b);push@fskey,$path}return sub {my$cb=shift;my@events;while(1){my$idx=Win32::ChangeNotify::wait_any(\@notify);Carp::croak("Can't wait notifications, maybe ".scalar(@notify)." directories exceeds limitation.")if!defined$idx;if($idx > 0){--$idx;my$new_fs=_full_scan($fskey[$idx]);$notify[$idx]->reset;my$old_fs=+{map {($_=>$fs->{$_})}keys %$new_fs };_compare_fs($old_fs,$new_fs,sub {push@events,{path=>$_[0]}});$fs->{$_}=$new_fs->{$_}for keys %$new_fs;last if@events}}$cb->(@events)}}}sub wait_timer {my@path=@_;my$fs=_full_scan(@path);return sub {my$cb=shift;my@events;while (1){sleep 2;my$new_fs=_full_scan(@path);_compare_fs($fs,$new_fs,sub {push@events,{path=>$_[0]}});$fs=$new_fs;last if@events};$cb->(@events)}}sub _compare_fs {my($old,$new,$cb)=@_;for my$dir (keys %$old){for my$path (keys %{$old->{$dir}}){if (!exists$new->{$dir}{$path}){$cb->($path)}elsif (!$new->{$dir}{$path}{is_dir}&& ($old->{$dir}{$path}{mtime}!=$new->{$dir}{$path}{mtime}|| $old->{$dir}{$path}{size}!=$new->{$dir}{$path}{size})){$cb->($path)}}}for my$dir (keys %$new){for my$path (sort grep {!exists$old->{$dir}{$_}}keys %{$new->{$dir}}){$cb->($path)}}}sub _full_scan {my@paths=@_;require File::Find;my%map;for my$path (@paths){my$fp=eval {Cwd::realpath($path)}or next;File::Find::finddepth({wanted=>sub {my$fullname=$File::Find::fullname || File::Spec->rel2abs($File::Find::name);$map{Cwd::realpath($File::Find::dir)}{$fullname}=_stat($fullname)},follow_fast=>1,follow_skip=>2,no_chdir=>1,},$path);delete$map{$fp}{File::Spec->rel2abs($fp)}}return \%map}sub _stat {my$path=shift;my@stat=stat$path;return {path=>$path,mtime=>$stat[9],size=>$stat[7],is_dir=>-d _ }}1;
FILESYS_NOTIFY_SIMPLE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use Filesys::Notify::Simple;

$| = 1;
my $spot = "$ENV{HOME}/test";
my $watcher = Filesys::Notify::Simple->new([ $spot ]);
daemon();

while (1) {
        $watcher->wait(sub {
                for my $event (@_) {
                    noti($event->{path});
                }
        });
}

sub noti {
        my $path = shift;
        print "$path\n";
        open(my $fh,'>>','/tmp/notifs.json') || die "cant open file $!";
        print $fh "$path\n";
        close $fh;
}

sub daemon {
        no strict 'subs';
            chdir '/'               or die "Can't chdir to /: $!";
                open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
                    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
                       
                defined(my $pid = fork) or die "Can't fork: $!";
                    exit if $pid;
                        setsid                  or die "Can't start a new session: $!";
                            open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
                        }
